from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, List, Dict, Any
from datetime import datetime
from decimal import Decimal


class Signal(Enum):
    """Trading signals generated by strategies."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    EXIT_LONG = "EXIT_LONG"
    EXIT_SHORT = "EXIT_SHORT"


class OrderType(Enum):
    """Order types supported by brokers."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LOSS = "SL"
    STOP_LOSS_MARKET = "SL-M"


@dataclass
class MarketData:
    """Real-time market data for a symbol."""
    symbol: str
    ltp: Decimal              # Last traded price
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int
    timestamp: datetime
    bid: Decimal
    ask: Decimal
    bid_qty: int = 0
    ask_qty: int = 0
    oi: int = 0               # Open interest (for F&O)

    @property
    def spread(self) -> Decimal:
        return self.ask - self.bid


@dataclass
class Position:
    """Current position in a symbol."""
    symbol: str
    exchange: str
    quantity: int             # +ve for long, -ve for short
    avg_price: Decimal
    current_price: Decimal
    pnl: Decimal = Decimal("0")
    pnl_percent: Decimal = Decimal("0")

    @property
    def is_long(self) -> bool:
        return self.quantity > 0

    @property
    def is_short(self) -> bool:
        return self.quantity < 0

    @property
    def market_value(self) -> Decimal:
        return abs(self.quantity) * self.current_price


@dataclass
class Order:
    """Order generated by a strategy."""
    symbol: str
    exchange: str
    signal: Signal
    quantity: int
    order_type: OrderType = OrderType.MARKET
    price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    target: Optional[Decimal] = None
    reason: str = ""

    def __post_init__(self):
        if self.order_type == OrderType.LIMIT and self.price is None:
            raise ValueError("Limit orders require a price")


@dataclass
class StrategyContext:
    """Context provided to strategies during execution."""
    strategy_id: str
    user_id: str
    subscription_id: str
    capital: Decimal
    max_positions: int
    max_drawdown_percent: Decimal
    daily_loss_limit: Decimal
    per_trade_sl_percent: Decimal
    is_paper_trading: bool
    positions: List[Position] = field(default_factory=list)
    today_pnl: Decimal = Decimal("0")
    total_pnl: Decimal = Decimal("0")
    realized_pnl: Decimal = Decimal("0")
    unrealized_pnl: Decimal = Decimal("0")

    @property
    def available_capital(self) -> Decimal:
        """Capital available for new positions."""
        used_capital = sum(p.market_value for p in self.positions)
        return self.capital - used_capital

    @property
    def drawdown_percent(self) -> Decimal:
        """Current drawdown percentage."""
        if self.capital == 0:
            return Decimal("0")
        return (self.total_pnl / self.capital) * 100

    def get_position(self, symbol: str) -> Optional[Position]:
        """Get position for a symbol."""
        for position in self.positions:
            if position.symbol == symbol:
                return position
        return None

    def has_position(self, symbol: str) -> bool:
        """Check if there's a position for a symbol."""
        return self.get_position(symbol) is not None


class BaseStrategy(ABC):
    """
    Base class for all trading strategies.

    All platform strategies must inherit from this base class and implement
    the required abstract methods.

    Example:
        class MyStrategy(BaseStrategy):
            name = "My Strategy"
            description = "A simple trading strategy"

            def on_market_data(self, data: MarketData) -> Optional[Order]:
                # Your trading logic here
                return None
    """

    # Strategy metadata (override in subclass)
    name: str = "Unnamed Strategy"
    description: str = ""
    version: str = "1.0.0"
    author: str = "Platform"
    min_capital: Decimal = Decimal("10000")
    supported_symbols: List[str] = []
    timeframe: str = "1min"  # 1min, 5min, 15min, 1hour, 1day

    def __init__(self, context: StrategyContext):
        """
        Initialize the strategy with context.

        Args:
            context: The strategy execution context
        """
        self.context = context
        self._state: Dict[str, Any] = {}
        self._is_running = False
        self._is_paused = False

    @abstractmethod
    def on_market_data(self, data: MarketData) -> Optional[Order]:
        """
        Called on every market data tick.

        This is the main method where trading logic should be implemented.
        Return an Order to place a trade, or None to do nothing.

        Args:
            data: Real-time market data for a symbol

        Returns:
            An Order to execute, or None
        """
        pass

    def on_order_filled(self, order: Order, fill_price: Decimal, fill_quantity: int) -> None:
        """
        Called when an order is filled.

        Override this method to handle order fill events.

        Args:
            order: The order that was filled
            fill_price: The actual fill price
            fill_quantity: The quantity that was filled
        """
        pass

    def on_order_rejected(self, order: Order, reason: str) -> None:
        """
        Called when an order is rejected.

        Override this method to handle order rejection events.

        Args:
            order: The order that was rejected
            reason: The rejection reason
        """
        pass

    def on_order_cancelled(self, order: Order, reason: str) -> None:
        """
        Called when an order is cancelled.

        Args:
            order: The order that was cancelled
            reason: The cancellation reason
        """
        pass

    def on_start(self) -> None:
        """
        Called when strategy starts.

        Override this method to perform initialization tasks.
        """
        self._is_running = True
        self._is_paused = False

    def on_stop(self) -> None:
        """
        Called when strategy stops (graceful shutdown).

        Override this method to perform cleanup tasks.
        This is also a good place to close open positions if needed.
        """
        self._is_running = False

    def on_pause(self) -> None:
        """
        Called when strategy is paused.

        When paused, on_market_data will not be called.
        """
        self._is_paused = True

    def on_resume(self) -> None:
        """
        Called when strategy resumes from pause.
        """
        self._is_paused = False

    def on_position_opened(self, position: Position) -> None:
        """
        Called when a new position is opened.

        Args:
            position: The newly opened position
        """
        pass

    def on_position_closed(self, position: Position, pnl: Decimal) -> None:
        """
        Called when a position is closed.

        Args:
            position: The closed position
            pnl: The realized P&L
        """
        pass

    def on_risk_limit_hit(self, limit_type: str, current_value: Decimal, limit_value: Decimal) -> None:
        """
        Called when a risk limit is hit.

        Args:
            limit_type: Type of limit hit (drawdown, daily_loss, etc.)
            current_value: Current value that triggered the limit
            limit_value: The limit value
        """
        pass

    def get_state(self) -> Dict[str, Any]:
        """
        Return current strategy state for persistence.

        Override this method to save custom state that should be
        persisted across restarts.

        Returns:
            Dictionary of state to persist
        """
        return self._state.copy()

    def set_state(self, state: Dict[str, Any]) -> None:
        """
        Restore strategy state (for recovery after restart).

        Override this method to restore custom state.

        Args:
            state: Previously saved state dictionary
        """
        self._state = state.copy()

    @property
    def is_running(self) -> bool:
        """Check if strategy is currently running."""
        return self._is_running and not self._is_paused

    def calculate_position_size(
        self,
        price: Decimal,
        risk_percent: Optional[Decimal] = None,
        stop_loss: Optional[Decimal] = None,
    ) -> int:
        """
        Calculate position size based on risk management.

        Args:
            price: Entry price
            risk_percent: Percentage of capital to risk (default: per_trade_sl_percent)
            stop_loss: Stop loss price for risk calculation

        Returns:
            Number of units to buy/sell
        """
        if risk_percent is None:
            risk_percent = self.context.per_trade_sl_percent

        if stop_loss:
            # Risk-based position sizing
            risk_per_unit = abs(price - stop_loss)
            if risk_per_unit == 0:
                return 0
            risk_amount = self.context.available_capital * (risk_percent / 100)
            quantity = int(risk_amount / risk_per_unit)
        else:
            # Simple percentage-based sizing
            allocation = self.context.available_capital * (risk_percent / 100)
            quantity = int(allocation / price)

        return max(0, quantity)
